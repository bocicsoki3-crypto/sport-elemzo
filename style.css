/**************************************************************
* HTML_Builder.gs - HTML N√©zet Gener√°tor (V13.6 - Id≈ëvonal Jav√≠t√°s)
* Feladata: A HTML k√≥d el≈ë√°ll√≠t√°sa.
* V13.6 V√ÅLTOZ√ÅSOK: A "Prophetic Timeline" vizualiz√°ci√≥ja k√ºl√∂n kont√©nert kapott
* a jobb elrendez√©s √©s a sz√∂vegt≈ël val√≥ elv√°laszt√°s √©rdek√©ben.
* V13.5 V√ÅLTOZ√ÅSOK: Hozz√°adva a bizalmi szint sz√∂veges √©rtelmez√©se
* a F≈ë Elemz≈ë Aj√°nl√°sa k√°rty√°hoz.
* V13.4 V√ÅLTOZ√ÅSOK: V√©glegesen elt√°vol√≠tva a felesleges fejleszt≈ëi kommentek.
* A szak√©rt≈ëi bizalom m√©r≈ëm≈±szer hibakezel√©se jav√≠tva.
**************************************************************/

// A buildAnalysisHtml funkci√≥ defin√≠ci√≥ja fogadja a masterRecommendation param√©tert
function buildAnalysisHtml(committeeResults, matchData, oddsData, valueBets, modelConfidence, sim, masterRecommendation) {
    const { home, away, sport, mainTotalsLine, mu_h, mu_a, propheticTimeline } = matchData;
    const { generalAnalysis, tacticalBriefing, propheticScenario, expertConfidence, playerMarkets, riskAssessment, keyQuestions, strategicClosingThoughts, microAnalyses } = committeeResults;
    let html = '';
    try {
        // Determine Best Bet display logic (Value vs. Most Likely)
        let bestBet, betConfidence, betType;
        if (valueBets && Array.isArray(valueBets) && valueBets.length > 0 && valueBets[0].value > 1.0) { // Value threshold > 1%
            bestBet = valueBets[0].market;
            betConfidence = Math.min(10.0, (valueBets[0].value / 5) + 5.0).toFixed(1) + "/10";
            betType = "√ârt√©ket Rejt≈ë Tipp ‚≠ê";
        } else {
            // Find highest probability outcome among main markets
            const mainMarketOutcomes = [
                { name: `Hazai`, prob: sim.pHome || 0 },
                { name: `Vend√©g`, prob: sim.pAway || 0 },
                { name: `Over ${mainTotalsLine}`, prob: sim.pOver || 0 },
                { name: `Under ${mainTotalsLine}`, prob: sim.pUnder || 0 }
            ];
            if (sport !== 'basketball' && (sim.pDraw || 0) > 0.1) { // Check sim.pDraw exists
                mainMarketOutcomes.push({ name: `D√∂ntetlen`, prob: sim.pDraw });
            }
            const highestProbOutcome = mainMarketOutcomes.reduce((a, b) => (a.prob > b.prob ? a : b), { prob: -1 });
            bestBet = highestProbOutcome.prob > -1 ? highestProbOutcome.name : "N/A";
            betConfidence = `${modelConfidence?.toFixed(1) || 'N/A'}/10`;
            betType = "Legval√≥sz√≠n≈±bb kimenetel";
        }

        // Format probabilities safely
        const pHome = sim.pHome || 0;
        const pDraw = sim.pDraw || 0;
        const pAway = sim.pAway || 0;
        const pOver = sim.pOver || 0;
        const pUnder = sim.pUnder || 0;

        // Totals card content generator
        const totalsContent = () => {
            const line = mainTotalsLine ?? (SPORT_CONFIG[sport]?.totals_line || 2.5);
            return `
                <div class="totals-breakdown">
                    <div class="total-line"><span class="total-label">Over ${line}</span><span class="total-value glowing-text">${pOver.toFixed(1)}%</span></div>
                    <div class="total-line"><span class="total-label">Under ${line}</span><span class="total-value glowing-text">${pUnder.toFixed(1)}%</span></div>
                </div>`;
        }; // <<<<----- Itt volt a hiba val√≥sz√≠n≈±leg a kor√°bbi verzi√≥kban (most jav√≠tva)

        // Parse Expert Confidence safely
        let expertConfidenceScore = "N/A", expertConfidenceJustification = "√ârt√©kel√©s hi√°nyzik.";
        if (expertConfidence && typeof expertConfidence === 'string') {
            const parts = expertConfidence.split(' - ');
            if (parts.length >= 2) {
                expertConfidenceScore = parts[0].replace(/\*+/g, '').trim();
                expertConfidenceJustification = parts.slice(1).join(' - ').trim();
            } else {
                const scoreMatch = expertConfidence.match(/(\d{1,2}\.?\d?\/10)/);
                if (scoreMatch) {
                    expertConfidenceScore = scoreMatch[1];
                    expertConfidenceJustification = expertConfidence.replace(scoreMatch[0], '').replace(/^[\s-]+|[\s-]+$/g, '').trim();
                } else {
                     expertConfidenceJustification = expertConfidence.trim() || "Indokl√°s hi√°nyzik.";
                }
            }
        }


        // Bizalmi szint √©rt√©kel≈ë sz√∂veg gener√°l√°sa
        const getConfidenceInterpretation = (score) => {
            if (typeof score !== 'number' || isNaN(score)) {
                return '<p class="confidence-interpretation low">A bizalmi szint nem √©rt√©kelhet≈ë.</p>';
            }
            if (score >= 9.0) {
                return '<p class="confidence-interpretation very-high">üíé **Nagyon Magas Bizalom (9.0-10.0):** Kiv√©telesen er≈ës jelz√©s. Az elemz√©s legt√∂bb eleme egy ir√°nyba mutat. Megfontoland√≥ magasabb t√©ttel.</p>';
            } else if (score >= 7.0) {
                return '<p class="confidence-interpretation high">‚úÖ **Magas Bizalom (7.0-8.9):** Er≈ës jelz√©s. Az adatok √©s kontextus nagyr√©szt √∂sszhangban. Megb√≠zhat√≥ opci√≥nak t≈±nik szok√°sos t√©ttel.</p>';
            } else if (score >= 5.0) {
                return '<p class="confidence-interpretation medium">ü§î **K√∂zepes Bizalom (5.0-6.9):** Megfontoland√≥. Lehet √©rt√©k, de vannak kock√°zatok/ellentmond√°sok. Csak m√©rs√©kelt t√©ttel javasolt.</p>';
            } else if (score >= 3.0) {
                return '<p class="confidence-interpretation low">‚ö†Ô∏è **Alacsony Bizalom (3.0-4.9):** Magas Kock√°zat! Jelent≈ës ellentmond√°sok vagy kock√°zati t√©nyez≈ëk. Csak spekulat√≠v, alacsony t√©ttel vagy ker√ºlend≈ë.</p>';
            } else {
                return '<p class="confidence-interpretation very-low">‚ùå **Nagyon Alacsony Bizalom (1.0-2.9):** Ker√ºlend≈ë! Kritikus ellentmond√°sok. Az AI csak k√©nyszerb≈ël adott tippet.</p>';
            }
        };
        const confidenceTextHtml = getConfidenceInterpretation(masterRecommendation?.final_confidence);

        // --- Build HTML ---
        html += `
            <div class="at-a-glance-grid">
                <div class="summary-card">
                    <h5>V√©geredm√©ny (1X2)</h5>
                    <div class="radial-chart-container">
                       <svg class="radial-chart" viewBox="0 0 120 120">
                           <circle class="track" cx="60" cy="60" r="54" /><circle class="progress away" cx="60" cy="60" r="54" style="--value: ${pAway}; --circumference: 339.29" />
                            ${pDraw > 0.1 ? `<circle class="track" cx="60" cy="60" r="44" /><circle class="progress draw" cx="60" cy="60" r="44" style="--value: ${pDraw}; --circumference: 276.46" />` : ''}
                            <circle class="track" cx="60" cy="60" r="34" /><circle class="progress home" cx="60" cy="60" r="34" style="--value: ${pHome}; --circumference: 213.62" />
                        </svg>
                    </div>
                    <div class="diagram-legend">
                        <div class="legend-item"><span class="legend-color-box" style="background:var(--primary);"></span>Hazai (<span class="glowing-text">${pHome.toFixed(1)}%</span>)</div>
                        <div class="legend-item"><span class="legend-color-box" style="background:var(--accent);"></span>Vend√©g (<span class="glowing-text">${pAway.toFixed(1)}%</span>)</div>
                        ${pDraw > 0.1 ? `<div class="legend-item"><span class="legend-color-box" style="background:var(--text-secondary);"></span>D√∂ntetlen (<span class="glowing-text">${pDraw.toFixed(1)}%</span>)</div>` : ''}
                    </div>
                </div>
                <div class="summary-card">
                    <h5>V√°rhat√≥ G√≥lok (xG)</h5>
                    <div class="xg-value-container">
                        <div class="xg-team">
                            <div class="value glowing-text">${(mu_h || 0).toFixed(2)}</div>
                            <div class="details">${home || 'Hazai'}</div>
                        </div>
                        <div class="xg-separator">-</div>
                        <div class="xg-team">
                             <div class="value glowing-text">${(mu_a || 0).toFixed(2)}</div>
                             <div class="details">${away || 'Vend√©g'}</div>
                        </div>
                    </div>
                </div>
                <div class="summary-card">
                   <h5>${sport === 'basketball' ? 'Pontok' : 'G√≥lok'} √ñsszesen</h5>
                    ${totalsContent()}
                 </div>
                <div class="summary-card">
                    <h5>${betType}</h5>
                     <div class="value glowing-text">${bestBet}</div>
                     <div class="details">Bizalmi szint: <strong class="glowing-text">${betConfidence}</strong></div>
                </div>
                <div class="summary-card">
                    <h5>Modell Magabiztoss√°ga üéØ</h5>
                    <div class="gauge-container">
                        <svg class="gauge-svg" viewBox="0 0 120 120">
                           <path class="gauge-track" d="M 30 90 A 50 50 0 1 1 90 90" />
                            <path class="gauge-value" d="M 30 90 A 50 50 0 1 1 90 90" style="stroke-dashoffset: calc(235.6 * (1 - (${modelConfidence || 0} / 10)))" />
                        </svg>
                        <div class="gauge-text glowing-text">
                            ${(modelConfidence || 0).toFixed(1)}<span class="gauge-label-inline">/10</span>
                        </div>
                    </div>
                    <div class="details">Adatkonzisztencia</div>
                </div>
            </div>

            <div class="summary-card expert-confidence-card">
                <h5>Szak√©rt≈ëi Magabiztoss√°g üß†</h5>
                <div class="gauge-container">
                    <svg class="gauge-svg" viewBox="0 0 120 120">
                        <path class="gauge-track" d="M 30 90 A 50 50 0 1 1 90 90" />
                        <path class="gauge-value" d="M 30 90 A 50 50 0 1 1 90 90" style="stroke-dashoffset: calc(235.6 * (1 - (${parseFloat(expertConfidenceScore) || 0} / 10)))" />
                    </svg>
                    <div class="gauge-text">${expertConfidenceScore}</div>
                </div>
                <div class="details" style="margin-top: 1rem;">${expertConfidenceJustification}</div>
             </div>
        `;

        // Value Bets Section
        if (valueBets && Array.isArray(valueBets) && valueBets.length > 0) {
            html += `<div class="market-data-section"><h4>√ârt√©ket Rejt≈ë Fogad√°sok (Value Bets)</h4>`;
            valueBets.forEach(bet => {
                 if (bet?.market && bet.odd && bet.stake && bet.value) {
                     const betData = { date: new Date().toISOString(), sport: bet.sport || sport, home: bet.home || home, away: bet.away || away, market: bet.market, odd: bet.odd, stake: bet.stake };
                     html += `<div class="list-item">
                                <div style="flex-grow:1;">
                                    <div class="list-item-title">${bet.market} @ ${bet.odd.toFixed(2)}</div>
                                    <div class="list-item-meta">Javasolt t√©t (Kelly): ${bet.stake.toFixed(2)}% | √ârt√©k: +${bet.value.toFixed(2)}%</div>
                                </div>
                                <button class="btn btn-primary" onclick='logBet(${JSON.stringify(betData)})'>Napl√≥z√°s</button>
                           </div>`;
                }
            });
            html += `</div>`;
        }

        // Player Markets Section
        if (playerMarkets && typeof playerMarkets === 'string' && playerMarkets.trim() && !playerMarkets.toLowerCase().includes("nincsenek kiemelt")) {
          html += `<div class="market-data-section"><h4>Kulcsj√°t√©kosok Piacai</h4><p>${playerMarkets.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>')}</p></div>`;
        }

        // Key Questions Section
        if (keyQuestions && typeof keyQuestions === 'string' && keyQuestions.trim()) {
            const cleanedQuestions = keyQuestions.replace(/^- /gm, '').trim();
            html += `<div class="analysis-section"><h4>Kulcsk√©rd√©sek</h4><p>- ${cleanedQuestions.replace(/\n/g, '<br>- ')}</p></div>`;
        }

        // Market Data Sections (Probabilities)
        const renderDataSection = (title, data) => {
            if (!data || typeof data !== 'object' || Object.keys(data).length === 0 || Object.values(data).every(v => typeof v !== 'number' || v < 0.1)) return '';
            let content = Object.keys(data)
                .filter(key => typeof data[key] === 'number' && data[key] >= 0.1)
                .map(key => {
                    let displayKey = String(key)
                        .replace(/o(\d+(\.\d+)?)/g, 'Over $1')
                        .replace(/u(\d+(\.\d+)?)/g, 'Under $1');
                    return `<div class="market-card">
                                <div class="market-card-title">${displayKey}</div>
                                <div class="market-card-value glowing-text">${data[key].toFixed(1)}%</div>
                           </div>`;
               }).join('');
            if (!content) return '';
            return `<div class="market-data-section"><h4>${title}</h4><div class="market-card-grid">${content}</div></div>`;
        };

        // Top Scores Section
        const top5scores = sim.scores ?
            Object.entries(sim.scores)
                            .sort(([,a],[,b]) => b-a)
                            .slice(0, 5)
                            .reduce((obj, [key, value]) => {
                                const simsCount = 50000;
                                if (typeof value === 'number' && simsCount > 0) {
                                    obj[key] = (value / simsCount) * 100;
                                }
                                return obj;
                            }, {}) : {};
        html += `<div class="market-data-grid-container">`;
        html += renderDataSection('V√©geredm√©ny Piacok (1X2)', { 'Hazai': pHome, 'D√∂ntetlen': pDraw > 0.1 ? pDraw : 0, 'Vend√©g': pAway });
        if(sim.pBTTS > 1) html += renderDataSection('G√≥l Piacok', { 'BTTS: Igen': sim.pBTTS });
        if (sport === 'soccer') {
             if (sim.corners && Object.keys(sim.corners).length > 0 && Object.values(sim.corners).some(v => v >= 0.1)) html += renderDataSection('Sz√∂glet Piacok', sim.corners);
             if (sim.cards && Object.keys(sim.cards).length > 0 && Object.values(sim.cards).some(v => v >= 0.1)) html += renderDataSection('Lap Piacok', sim.cards);
        }
        if (Object.keys(top5scores).length > 0) html += renderDataSection('Legval√≥sz√≠n≈±bb Eredm√©nyek', top5scores);
        html += `</div>`;

        // Specialist Micro-Analyses Section
        if (microAnalyses && typeof microAnalyses === 'object' && Object.keys(microAnalyses).length > 0) {
            html += '<div class="market-data-section"><h4>Specialista Elemz√©sek</h4>';
            Object.keys(microAnalyses).forEach(key => {
                 const analysisText = microAnalyses[key];
                 if (typeof analysisText !== 'string' || !analysisText.trim() || analysisText.toLowerCase().includes("adatok hi√°nyosak")) return;

                let title = key;
                switch(key) {
                    case 'btts': title = 'G√≥lv√°lt√°s (BTTS)'; break;
                    case 'goalsOU': title = `G√≥lok √ñsszesen (O/U ${mainTotalsLine ?? 'N/A'})`; break;
                    case 'corners': title = 'Sz√∂gletek'; break;
                    case 'cards': title = 'Lapok'; break;
                    case 'winner': title = 'Meccs Gy≈ëztese (V√©gs≈ë)'; break;
                    case 'pointsOU': title = `Pontok √ñsszesen (O/U ${mainTotalsLine ?? 'N/A'})`; break;
                    default: title = key.charAt(0).toUpperCase() + key.slice(1);
                }
                 html += `<div class="micromodel-card"><h5>${title}</h5><p>${analysisText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>')}</p></div>`;
            });
            html += '</div>';
        }

        // Accordion Section for Detailed Analyses
        html += '<div class="analysis-accordion">';
        const renderAccordionSection = (title, content, icon, isOpen = false) => {
            // K√ºl√∂n kezelj√ºk a Pr√≥f√©tai forgat√≥k√∂nyvet (az id≈ëvonal elt√°vol√≠t√°sra ker√ºlt)
            if (title === 'Pr√≥f√©tai Forgat√≥k√∂nyv') {
                const scenarioTextPart = content ? String(content).trim() : ''; // Biztons√°gos stringg√© alak√≠t√°s
                if (!scenarioTextPart || scenarioTextPart.toLowerCase().includes("adatok hi√°nyosak") || scenarioTextPart.toLowerCase().includes("nem √©rhet≈ë el")) return '';
                const formattedScenario = scenarioTextPart
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n{2,}/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/### (.*?)(<br>|$)/g, '<h4>$1</h4>')
                    .replace(/^- /gm, '&bull; ');

                return `<details ${isOpen ? 'open' : ''}>
                            <summary>
                               <span class="section-title">
                                   <svg class="section-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${icon}</svg>
                                   ${title}
                               </span>
                            </summary>
                            <div class="accordion-content">
                                <p>${formattedScenario}</p> {/* Csak a sz√∂veg P tagben */}
                            </div>
                        </details>`;
            } else { // Norm√°l renderel√©s a t√∂bbi szekci√≥hoz
                if (!content || typeof content !== 'string' || !content.trim() || content.toLowerCase().includes("adatok hi√°nyosak") || content.toLowerCase().includes("nem √©rhet≈ë el")) return '';
                const formattedContent = content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n{2,}/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/### (.*?)(<br>|$)/g, '<h4>$1</h4>')
                    .replace(/^- /gm, '&bull; ');

                return `<details ${isOpen ? 'open' : ''}>
                            <summary>
                               <span class="section-title">
                                   <svg class="section-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${icon}</svg>
                                   ${title}
                               </span>
                            </summary>
                            <div class="accordion-content"><p>${formattedContent}</p></div>
                        </details>`;
            }
        };


        html += renderAccordionSection('√Åltal√°nos Elemz√©s', generalAnalysis, '<path d="M12 20v-6M6 20v-10M18 20V4"/>', true);

        // --- VIZU√ÅLIS ID≈êVONAL TELJESEN ELT√ÅVOL√çTVA ---
        // A combinedPropheticHtml most m√°r csak a scenario sz√∂veg√©t tartalmazza
        const combinedPropheticHtml = `${propheticScenario || ''}`;
        html += renderAccordionSection('Pr√≥f√©tai Forgat√≥k√∂nyv', combinedPropheticHtml, '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="3" x2="9" y2="21"></line>', true);

        html += renderAccordionSection('Taktikai M√©lyelemz√©s', tacticalBriefing, '<polyline points="12 5 12 19 5 12 19 12 12 5"/>');
        html += renderAccordionSection('Kock√°zatkezel≈ëi Jelent√©s', riskAssessment, '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>');
        html += renderAccordionSection('Strat√©giai Z√°r√≥gondolatok', strategicClosingThoughts, '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>');
        html += '</div>'; // End of analysis-accordion


        // --- Mester Aj√°nl√°s K√°rtya ---
        if (masterRecommendation?.recommended_bet && typeof masterRecommendation.final_confidence === 'number') {
             html += `
                <div class="master-recommendation-card">
                    <h5>üëë F≈ë Elemz≈ë Aj√°nl√°sa üëë</h5>
                    <div class="master-bet glowing-text">${masterRecommendation.recommended_bet}</div>
                    <div class="master-confidence">V√©gs≈ë Bizalom: <strong class="glowing-text">${masterRecommendation.final_confidence.toFixed(1)}/10</strong></div>
                    <div class="master-reasoning">${masterRecommendation.brief_reasoning || ''}</div>
                    <div class="confidence-interpretation-container">${confidenceTextHtml}</div>
                </div>
            `;
        } else {
             Logger.log(`Hi√°nyz√≥ vagy √©rv√©nytelen Mester Aj√°nl√°s objektum a HTML gener√°l√°sakor.`);
             html += `<div class="master-recommendation-card" style="border-color: var(--danger); animation: none; box-shadow: none;"><p style="color: var(--danger);">A F≈ë Elemz≈ë aj√°nl√°sa hiba miatt jelenleg nem el√©rhet≈ë.</p></div>`;
        }


    } catch (e) {
        const matchInfo = `${matchData?.home || 'N/A'} vs ${matchData?.away || 'N/A'}`;
        Logger.log(`Hiba a HTML gener√°l√°s sor√°n (${matchInfo}): ${e.message} \nStack: ${e.stack}`);
        html = `<p style="padding: 2rem; text-align: center; color: var(--danger);">Hiba t√∂rt√©nt az elemz√©s HTML n√©zet√©nek gener√°l√°sa k√∂zben: ${e.message}</p>`;
    }
    return html;
}

// --- Value Calculation & Kelly Stake ---

function calculateValue(simulation, oddsData, sport, home, away) {
    if (!simulation || !oddsData?.current || !Array.isArray(oddsData.current)) { return null; }
    let valueBets = [];
    try {
        const markets = [];
        const simProbs = simulation;

        const findOdds = (names) => {
            const validNames = Array.isArray(names) ? names.filter(n => typeof n === 'string') : [];
            if (validNames.length === 0) return null;
            const outcome = oddsData.current.find(o => o && validNames.includes(o.name) && typeof o.price === 'number' && o.price > 1);
            return outcome ? outcome.price : null;
        };

        const homeName = sport === 'basketball' ? home : 'Hazai gy≈ëzelem';
        const awayName = sport === 'basketball' ? away : 'Vend√©g gy≈ëzelem';
        const drawName = 'D√∂ntetlen';
        const mainLine = simProbs.mainTotalsLine;
        const overName = `Over ${mainLine}`;
        const underName = `Under ${mainLine}`;
        const odds = {
            home: findOdds([home, homeName]),
            away: findOdds([away, awayName]),
            draw: (sport !== 'basketball') ? findOdds([drawName]) : null,
            over: findOdds([overName]),
            under: findOdds([underName])
        };
        if (typeof simProbs.pHome === 'number' && odds.home) markets.push({ name: homeName, probability: simProbs.pHome, odds: odds.home });
        if (typeof simProbs.pAway === 'number' && odds.away) markets.push({ name: awayName, probability: simProbs.pAway, odds: odds.away });
        if (odds.draw && typeof simProbs.pDraw === 'number') markets.push({ name: drawName, probability: simProbs.pDraw, odds: odds.draw });
        if (odds.over && typeof simProbs.pOver === 'number') markets.push({ name: overName, probability: simProbs.pOver, odds: odds.over });
        if (odds.under && typeof simProbs.pUnder === 'number') markets.push({ name: underName, probability: simProbs.pUnder, odds: odds.under });

        markets.forEach(market => {
            if (market.probability >= 0 && market.probability <= 100 && market.odds > 1) {
                const value = ((market.probability / 100) * market.odds - 1) * 100;
                if (value > 1.0) { // Value threshold
                    const stake = calculateKellyStake(market.probability, market.odds);

                    if (stake > 0.1) { // Stake threshold
                      if(home && away && sport && market.name && market.odds) {
                        valueBets.push({ home, away, sport, market: market.name, odd: market.odds, probability: market.probability, value, stake });
                      }
                    }
                }
            }
        });
    } catch (e) {
      Logger.log(`√ârt√©k sz√°m√≠t√°si hiba (${home} vs ${away}): ${e.message}`);
      return null;
    }

    return valueBets.length > 0 ? valueBets.sort((a, b) => b.value - a.value) : null;
}

function calculateKellyStake(probability, odds) {
  if (typeof probability !== 'number' || typeof odds !== 'number' || probability < 0 || probability > 100 || odds <= 1) { return 0; }
  try {
    const p = probability / 100;
    const b = odds - 1;
    const q = 1 - p;
    if ((p * b - q) <= 0) { return 0; }
    const kellyFraction = (p * b - q) / b;
    const fractionalKelly = kellyFraction * 0.25; // Quarter Kelly
    const stakePercentage = Math.max(0, fractionalKelly * 100);
    return stakePercentage;
  } catch (e) { Logger.log(`Kelly hiba: ${e.message}`); return 0; }
}
